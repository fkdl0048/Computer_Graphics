# 중간고사 문제 풀이

## 2016

### 1. 컴퓨터로 3차원 물체를 그리는 대표적인 방법으로 Ray Tracing이라는 방법이 있다. 이 방법이 무엇인지 간략히 설명하고, 이 방법이 갖는 장점과 단점을 쓰라.

- Ray Tracing의 의미
  - 빛을 쏘고 반사되는 과정을 계산하는 것으로 실제 세계의 물리적인 빛의 반사를 컴퓨터로 표현하는 것
  - 실제 세상에서는 단일 반사가 아닌 여러 반사가 복잡하게 이뤄지는데 이를 컴퓨터로 표현은 가능하지만 그 수가 기하급수로 늘어나기에 불가능에 가깝다.
  - 따라서 이를 흉내내는 기술이 발달하게 되었다.
  - 모든 빛을 계산하는 것이 아닌 시야각에서 빛을 쏘고 반사되는 과정을 계산한다. 이를 역추적이라고 한다.
- 장점
  - 실세계와 같은 표현이 가능하다.
- 단점
  - 사실적인 표현이 증가할수록 계산량이 기하급수적으로 증가한다. (표현하는 시간이 오래걸린다.)

### 2. 다음은 간략화된 그래픽스 파이프라인이다. 빈 칸 2곳에 들어가야 할 작업 과정이 무엇인지 각각 쓰고, 이 과정의 목적이 무엇인지 아래 칸에 간략히 설명하라

1. FragmentProcessing: 레스터라이징되어 나온 픽셀들을 처리하는 단계로 각 픽셀의 색상을 결정하는 단계이다. 실제 각 vertex에 의해 그려진 삼각형에 내부 픽셀들의 색상을 결정한다. 색상 말고도 깊이도 측정하여 해당 속성값을 결정한다.

2. Fragment Shader: 색상을 결정하는 쉐이더로 Vertex Shader에서 넘겨받은 out값을 통해 색상을 결정한다.

3. 작업 설명

### 3. transforamion에 대한 이름

Modeling Transformation:   
Viewing Transformation:   
Projection Transformation:


### 4. 다음과 같은 장면을 컴퓨터로 그리려고 한다. 이를 위해 OpenGL과 같은 그래픽스 API를 통해 설정해야할 요소를 크게 4 가지로 나눠 생각할 수 있다.

1. 카메라 정보
2. 물체 정보
3. 빛 정보
4. 속성 정보

### 5. GPU로 넘겨주는 vertex 정보는 VAO와 VBO로 포장하여 넘겨주게 된다 각각 설명하라

VAO: Vertex Array Object로. VBO를 담고 있는 객체, 여러 VBO를 담아서 사용한다.

VBO: Vertex Buffer Object로 vertex 정보를 담고 있는 객체이다. vertex 정보를 담고 있다. VBO를 활용하여 색상도 담을 수 있다.

### 6. 다음은 OpenGl Shading Language에서 랜더링 시에 CPU에서 GPU로 넘겨주는 데이터는 크게 Attribute와 Uniform으로 나눌 수 있다. 각각의 특징과 사용 용도 예를 설명하라

Attribute: cpu에서 쉐이더로 넘겨주는 데이터로 각 vertex의 위치를 넘겨준다. 쉐이더는 이를 받아 실제로 표현할 위치를 결정한다.

사용 예: cpu에서 정한 위치와 색상 데이터를 넘겨준다.

Uniform: cpu에서 지정한 데이터로 cpu에서 쉐이더의 값을 컨트롤 할 수 있는 데이터이다.

사용 예: 런타임에 영향을 받는 값으로 시간을 입력받아 deltaTime을 계산하여 사용한다.

### 7. 다음은 Shader code의 일부분이다. 코드의 실행을 통해 결정되는 변수 d의 값은 무엇일지 예측하라

6, 4, 2

### 8. Depth-Buffer 사용 목적과 원리에 대해 간략히 쓰라

목적: 3D 객체를 화면에 표시할 때 그려지는 순서에 따라 보여지는 순서가 달라지기 때문에 이를 해결하기 위해서 Z축 방향으로 깊이를 계산하여 그려지는 순서를 결정한다.

원리: 현재 깊이 값을 저장하는 버퍼로 각 픽셀에는 깊이 값을 저장한다. 이를 통해 깊이 값을 비교하여 그려지는 순서를 결정한다.

### 9. 

다음은  좌측과  같은  구(sphere)를  모델링하기  위해  고안한  방식을  설명한  도식이다.  먼저  구를  마치  지구본과 
같이  경도(longitude :  지구의  동서  방향으로  쪼갬을  의미)와  위도(latitude:  지구의  남북  방향을  의미)의  관점에서 
좌표를  표현하고자  한다.  아래  가운데  그림에서  i  방향이  경도  방향이며,  우측  그림에서  j  방향이  위도  방향이다. 
i 와  j 의  단위를  각도로  표기  한다면  (예: (30 도, 45 도)), (i ,j)의  좌표를  직교  (x,y,z)  좌표로  변환하는  식을  구하시오.  

경도와 위도를 각각 각도로 주어진 (i, j) 좌표를 라디안으로 변환합니다.

다음과 같은 공식을 사용하여 (i, j) 좌표를 (x, y, z) 좌표로 변환합니다:

x = r * cos(j) * cos(i)
y = r * cos(j) * sin(i)
z = r * sin(j)

여기서,

(i, j)는 각도로 표현된 경도와 위도입니다.
(x, y, z)는 직교 좌표로 표현된 3D 공간의 좌표입니다.
r은 구의 반지름입니다.
이러한 식을 사용하여 (i, j) 좌표를 직교 (x, y, z) 좌표로 변환할 수 있습니다. 이를 통해 구를 경도와 위도로 표현하고 모델링할 수 있습니다.

| 1  0  0  0 |
| 0  0 -1  0 |
| 0  1  0  0 |
| 0  0  0  1 |

## 2017

### 1. 

컴퓨터로  3차원  물체를  그리는  대표적인  방법으로  Ray  Tracing이라는  방법이  있다.  이  방법이  무엇인지  간략히 
설명하고,  수업시간에  다루고  있는  간략화  된  렌더링  파이프라인  (simplified  rendering  pipeline)과는  어떠한  점이 
다른지  차이점에  대해  설명하라

Ray Tracing의 의미
레이 트레이싱은 말 그대로 하나의 ray을 쏴 해당 레이를 추적하는 기술이다. 쉽게 말해 모든 빛을 그대로 구현할 수 없으니 시점 기준으로 레이를 쏴서 역추적(계산)하는 것 
조명, 그림자를 모방

렌더링 파이프라인과의 차이점
레이트레이싱은 상당한 비용이 발생하는데 비해 렌더링 파이프라인은 비교적 적은 비용이 발생한다. 실세계를 야매?적인 방법으로 흉내내기 때문에 극사실적인 표현보다 빠른 표현을 목적으로 한다.

### 2.

가장 큰 차이점은 사용자의 제어 가능영역으로 프로그래머가 직접 쉐이더를 작성하느냐의 차이가 가장 크다고 할 수 있다. 2.0이하 버전에서는 고정함수를 호출하여 렌더링 작업을 수행했다면 현재는 세이더 프로그래밍을 통해 좀 더 세밀한 렌더링 작업을 수행할 수 있다.

### 3.

꼭지점으로 계산된 삼각형을 통해 내부를 픽셀로 쪼개는 작업 Fragment로..

### 4.

보낼 데이터를 CPU에서 계산한 뒤 VBO, VAO를 생성, 연결한 뒤 shader를 통해서 데이터를 넘겨준다. vertex shader, atrribute로 연결, VBO는 VAO에 연결

### 5. 

원인: 화면에 그리는 순서에 따라 보여지는 순서가 달라지기 때문에 3D형태의 큐브가 아닌 빈 곳이 존재하게 된다.

해결방법: Z-Buffer를 사용하여 깊이를 계산하여 그리는 순서를 결정한다. Z-buffer란, 현재 깊이 값을 저장하는 버퍼로 각 픽셀에는 깊이 값을 저장한다. 이를 통해 깊이 값을 비교하여 그려지는 순서를 결정한다.

### 6. 

Modeling Transformation (모델 변환):
목적: 모델 변환은 3D 객체의 로컬 좌표 공간을 월드 좌표 공간으로 변환하는 데 사용됩니다. 이 변환은 객체의 위치, 회전 및 크기를 조절하며, 다수의 모델을 월드 공간에 배치할 수 있도록 합니다. 즉, 객체의 모양과 위치를 조정하는 데 사용됩니다.

Viewing Transformation (뷰 변환):
목적: 뷰 변환은 월드 좌표 공간에서의 객체의 위치를 카메라의 시점으로 변환합니다. 이 변환은 관찰자의 시선 방향, 시점 위치, 카메라의 방향 및 업 벡터 등을 고려하여 월드 좌표 공간을 카메라 좌표 공간으로 변환합니다. 즉, 뷰 변환은 카메라의 시각을 설정하는 데 사용됩니다.

Projection Transformation (투영 변환):
목적: 투영 변환은 뷰 공간의 3D 좌표를 2D 이미지 평면에 투영하는 데 사용됩니다. 이 변환은 원근 투영 또는 직교 투영과 같은 투영 기법을 적용하여 객체를 화면 공간으로 투영하고, 원근 및 깊이 효과를 생성합니다. 즉, 화면에 표시할 영역을 정의하고 원근 효과를 추가하는 데 사용됩니다.

### 7.

1. Uniform input
2. gl_Position

### 8.

### 9.

### 10.

오일러 각도란, 3D공간에서 회전을 설명하는 방법중 하나로 3개의 각도로 구성되며 각각의 각도는 공간 내에서 다른 축 주위의 회전을 나타낸다.

일반적으로 롤(x축 회전), 피치(y축 회전), 요(y축 회전)으로 구성된다.

## 2022

### 1.

1. 모델링: 3D공간에 나타내고자 하는 객체 또는 장면의 모델을 생성하는 과정으로 물체를 생성하는 방법이다. 단순 데이터로만 존재
2. 랜더링: 모델링된 물체를 화면에 표현하는 방법으로 빛과 광원등을 통해 물체를 표현한다.
3. 애니메이션: 물체의 움직임을 표현하는 방법이다.

### 2.

레이트레이싱은 광자에서 나온 빛을 표현하기 위한 방법으로 실제 세계의 물리적인 빛의 반사를 컴퓨터로 표현하는 것이다.

시점으로부터 레이를 쏴 계산하여 실세계를 흉내내는 것으로 실제 현상과 반대로 역 추적하여 계산한다.

### 3.

Rasterizer: 레스터라이저는 vertex로부터 연결되어 만들어진 삼각형에 내부 픽셀을 만들어내는 과정으로 각 픽셀들은 색상과 깊이를 가지고 있다. 이를 fragment라고 하며 이후 fragment shader에서 색상을 결정한다.

### 4. 

목적: Depth-buffer는 만들어진 순서대로 그려지는 것이 아닌 3D상의 실제 깊이를 계산하여 그려지는 순서를 결정하기 위한 것이다.

원리: 각 픽셀에는 깊이 값을 저장한다. 이를 통해 깊이 값을 비교하여 그려지는 순서를 결정한다. 즉, z축 기준으로 깊이를 계산하여 그려지는 순서를 결정한다. (레이어와 비슷하다.)

### 5.

Uniform input

gl_Position

### 6.

강체변형이란, 3D공간에서 물체의 위치, 회전, 크기를 조절하는 것이다. 변환행렬로 나타낸다.

판단법, 이동부분과 회전부분을 보고 판단한다.

이동부분은 상단 세로 열(마지막 열)은 이동변화를 나타내고 물체의 위치를 변화시킨다.

회전부분은 상단 왼쪽의 3x3 행렬은 회전변화를 나타내고 물체의 방향을 변화시킨다.

즉, 이동행렬은 x,y,z중 하나라도 0이 아니라면 이동이 발생한다는 뜻이고 회전행렬은 직교행렬인지 확인한다.

*직교행렬은 역행렬이 전치행렬과 같은 행렬이다.*


### 7.

Modeling Transformation (모델 변환):

Viewing Transformation (뷰 변환):

Projection Transformation (투영 변환):

### 8.


### 9.

도너스 모양의 한 점을 (φ, θ) 각도로 표현된 좌표에서 직교 좌표 (x, y, z)로 변환하기 위한 식을 아래에 제시합니다. 이 변환은 파라미터 R (외부 반지름) 및 r (내부 반지름)를 사용합니다.

주어진 (φ, θ) 좌표를 사용하여 직교 좌표 (x, y, z)를 구하는 방법은 다음과 같습니다:

먼저, θ와 φ를 라디안(radians)으로 변환합니다. 각도(°)에서 라디안으로 변환하기 위해서는 다음과 같이 수식을 사용합니다:

θ_rad = θ * (π / 180)
φ_rad = φ * (π / 180)
다음으로, x, y 및 z를 계산합니다. 다음의 수식을 사용하여 직교 좌표 (x, y, z)를 구합니다:

x = (R + r * cos(θ_rad)) * cos(φ_rad)
y = (R + r * cos(θ_rad)) * sin(φ_rad)
z = r * sin(θ_rad)
이러한 수식을 사용하여 (φ, θ) 좌표를 직교 좌표로 변환할 수 있으며, 이것은 도너스 모양(torus) 위의 한 점을 특정한 (φ, θ) 각도에서 (x, y, z) 좌표로 변환하는 데 사용됩니다.

### 10.

짐벌락은 3D 공간에서 객체가 회전을 다룰 때 발생할 수 있는 문제로 하나의 축을 기준으로 회전을 하다가 다른 축을 기준으로 회전을 하면서 회전축이 겹치는 문제이다.

주로 오일러 각도를 사용할 때 발생한다.

회전각도의 자유도가 제한되며, 특정한 방향으로 회전할 때 다른 두 축의 회전각도가 겹치거나 중첩되는 현상을 말한다.

